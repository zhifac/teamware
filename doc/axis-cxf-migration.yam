Migrating from Axis to CXF

%contents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%1 Background

We used to use Apache Axis 1.3 to power our web services in SAFE.  Axis 1
ceased active development in 2006 (version 1.3 was released in October 2005,
the final version 1.4 in April 2006) and has a number of bugs and shortcomings,
some of which we were able to work around but not all.  The particular problem
that pushed us over the edge was a bug in Axis that caused it to run out of
memory when processing large SOAP messages.  Newer toolkits, based on the new
JAX-WS API, have support for transparently handling large blobs of data as
attachments and it is hoped that this will not only cut our memory usage but
will also hopefully increase performance and throughput.  Only time will
tell...

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%1 Five minute guide

- If you are accessing services through the proxy components (executive-proxy,
  docservice-proxy, etc.) you shouldn't notice too many differences.
  - The exception is when handling blobs of XML - see below for details.
- Where you previously imported a client stubs JAR file, you now need to import
  the corresponding "-api" JAR instead:
  - docservice-client.jar -> docservice-api.jar
  - executive-client-stubs.jar -> executive-callback-service-api.jar
  - gas-client-stubs.jar -> gas-endpoint-api.jar
- See ExecutiveProxyFactoryImpl for an example of how to create a client stub
  with CXF.  There is no longer a specific service locator to create, you just
  use the generic JaxWsProxyFactoryBean.  The stub you get back implements _the
  same Java interface_ as the real service object, so for testing purposes you
  could drop in an implementation object in place of the stub.
- There are static methods in gleam.util.cxf.CXFClientUtils to handle turning
  off chunking, enabling GZIP compression, etc.  Again, see
  ExecutiveProxyFactoryImpl for examples.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%1 Package name changes

With Axis web services, we needed to first generate WSDL from the implemented
service, and then back-generate client code from that WSDL.  In some cases it
was possible to be careful and have the re-generated code match the package
names and interfaces of the service but in other cases the client stubs were
generated into a different package, and sometimes had different method
signatures (Axis-generated stub methods always throw RemoteException).

CXF can operate the same way, but it also supports a different approach.  You
define a Java interface giving the methods your service is to expose, and add
annotations (@WebService, @WebMethod, etc.) to that interface.  Your web
service object then implements this interface.  Now when you need a client stub
for that service, you use the same interface and CXF generates your client
proxy dynamically.  It is able to do this because protocol-level exceptions in
JAX-WS are RuntimeExceptions - it doesn't require RemoteException on your
interfaces.  This approach also has the advantage that for testing purposes you
can use a real implementation object anywhere that usually expects a web
service stub.

So:
- gleam.docservice.client.SerialDocService -> gleam.docservice.DocService
- gate.creole.ontology.owlim.client.OWLIM -> gate.creole.ontology.owlim.OWLIM

The GaS and executive callback service interfaces have not changed package, but
the methods no longer throw RemoteException.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%1 Handling of XML blobs

In the old Axis-based web services there were many places where we passed blobs
of XML back and forth as string values within the SOAP message.  I tried to
optimise this as much as possible but it's not generally good to pass XML as
text.  JAX-WS (the spec implemented by CXF) provides a neat way around this.
If your service has a parameter or return value whose XML schema type is
xsd:base64Binary then rather than encoding the value as base 64 and putting it
directly in the SOAP envelope, JAX-WS provides the option to transparently send
it as a MIME attachment and re-assemble the message at the other end.

To make use of this feature (called "MTOM"), I have had to change various
method signatures, mostly in the doc service but also the GATE-mode
processDocument method of the GaS, to take XML data as a byte[] instead of a
String.  In particular:

- in gleam.docservice.DocService
  - createDoc(String name, {String corpusID,} String content) ->
    createDoc(String name, {String corpusID,} byte[] content, String encoding)
  - String getDocXML(String docID) -> byte[] getDocXML(String docID)
  - setAnnotationSet(String xmlContent, String taskID, boolean keepLock) ->
    setAnnotationSet(byte[] xmlContent, String taskID, boolean keepLock) ->
  - String getNextSearchResults(String searcherID, int numRecords) ->
    byte[] getNextSearchResults(String searcherID, int numRecords) ->
- in gleam.docservice.AnnotationSetHandle
  - data is now a byte[] rather than a String
- in gleam.gateservice.endpoint.GateWebService
  - processDocument(String docXml, ParameterValue[] params) ->
    processDocument(byte[] docXml, String encoding, List<ParameterValue> params)
- in gleam.gateservice.endpoint.AnnotationSetData
  - xmlData is now a byte[] rather than a String

Where there is no explicit "encoding" parameter, UTF-8 must be used.  In most
cases you will _not_ need to create a String as an intermediate step to or from
the byte[].  For example, when dealing with annotation sets using
DocumentStaxUtils the stax parser can just as happily work with a
ByteArrayInputStream as with a StringReader.  See
DocServiceProxyImpl.getAnnotationSet for an example.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%1 Build changes

The most obvious change in build.xml is that instead of

<patternset refid^"pattern.axis"/>

you now use

<patternset refid^"pattern.cxf"/>

Also, we no longer need to generate client stubs JAR files, but instead I have
had to split off the interface code for each SAFE component into a separate
source tree from the implementation, to be packaged into a separate JAR file.
The idea is that the -api file needs to contain everything that is shared by
both the client and server sides, typically:

- The service interface, with @WebService, @WebMethod, @WebParam, etc.
  annotations.
- Any JavaBean classes that are used as parameter and/or return types for the
  service interface methods.
- Exceptions thrown by the interface methods.
- Possibly a package-info.java.

Everything else goes in the main JAR file - the service implementation class,
any support classes, and any classes used for the Spring configuration of the
service.

The build.xml will first build the api JAR, then compile the service classes
with the api JAR on the classpath.  This ensures that code in the API can't
accidentally depend on implementation classes.
