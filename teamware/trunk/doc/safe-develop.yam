SAFE Developer Notes

Note: this is out of date and needs revising!

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%contents


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%1 Introduction

This documents contains developer notes for SAFE and describes the different
components of the SAFE architecture.  For an overview of SAFE and its
applications see %(./gleam-reqs.html).  SAFE will be based on a Service
Oriented Architecture (SOA) with different modules communicating via Web
Services.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%1 Overview

The SAFE architecture will be made of several modules communicating with each
other, as showed on the following figure:

%image(images/gleam-modules2.png)

The schema above splits the architecture of SAFE into 3 tiers:

- application side
- SAFE core
- user GUI's

In the user GUIs part, the green boxes correspond to user interfaces
used by different profiles of actors (see %(./gleam-reqs.html)). 

The core SAFE is made of several modules which communicate via web services, 
the description of which will be given in annex of this document. 

Finally, the application realm uses the data generated by SAFE and located in a
DocService or/and in an Ontology Service. These data could be converted and used
directly by an instance of a KIM Server, in which case one could for instance 
reuse the functionalities of the KIM web clients.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%1 Batch, Mixed Initiative and Active Learning in SAFE

%include(learning.yam)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%1 Description of the modules

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 Executive module

The SAFE executive module will be accessible as a Web Service. Its role is to
combine the different SAFE modules into an application and provide a link
between them. An Information Curator will configure an Executive via a specific
interface, probably a web application and / or GATE, in order to build a
specific *workflow*. 
An Executive module can handle one workflow at a time, which means that two
different applications (e.g. MOWER (Mining Opinion from WEb Resources),
News Analysis) will have to
run as different instances of the Executive. A workflow will be created by an
Information Curator, via a dedicated web interface. A workflow can also be
defined via a XML file (as in YALE for instance).

An Executive has also the role of keeping a queue of tasks. A task is
associated to a document (or a set of documents) and a process (e.g.
GATEService) and have a priority. This priority can be used for instance to
force a document to be manually annotated as soon as possible.

A detailed example of workflow is given at the end of this document.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 AnnotatorPool

An AnnotatorPool represents a set of Human Annotators (HA) used for a specific
application. This module is used by an Information Curator to manage the Human
Annotators, decide how to distribute the documents among them, or define how
to merge their annotations. 

Some functionalities will be available to the Executive from this module, like
managing the HAs:
- Add Annotator (userid)
- Remove Annotator (userid)

- Specify the AnnotationSets or Annotation types that a HA can see 
(done at the initialisation of the Pool). 

*Note*: An AnnotationSet for a specific user will be created on each annotated
document instead of duplicating the documents for each HA. The name of the AS
is the ID of the HA.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 GATEService (aka GaS)

(See also the %(gas-user-guide.html, GaS User Guide).)

A GATEService is defined here as a pipeline of GATE PR's which is available
via a WebService. In the SAFE architecture, it is called from an Executive. A
GATEService can be a front-end to a set of GATE engines running on different
servers in order to gain in scalability. The configuration of the GATEService
will specify this behaviour. It is transparent to the external user of the
GATEService how many machines are actually used to produce an annotation.

A GaS can declare required and optional parameters whose values are provided by
the caller.  The parameter values are mapped onto either feature values on the
document being processed by the embedded GATE PRs, or runtime parameter values
of the various PRs that make up the application.  The mapping is defined in a
_service definition_, an XML file supplied by the GaS creator:
%<
&lt;parameters>
  &lt;param name\="depth">
    &lt;runtimeParameter prName\="MyAnnotator" prParam\="maxDepth" />
  &lt;/param>
  &lt;param name\="annotatorName">
    &lt;documentFeature name\="annotator" />
  &lt;/param>
&lt;/parameters>
%>

Parameter values are all strings, but when mapping to PR parameters the usual
GATE ^Resource.setParameterValue()^ is used, which can convert strings into
other types (e.g. URL, Integer, etc.).

The service definition also specifies what annotation sets the service requires
as input and populates as output:
%<
&lt;annotationSets>
  &lt;annotationSet name\="Original markups" in\="true" />
  &lt;annotationSet name\="" out\="true" />
  &lt;annotationSet name\="Key" in\="true" out\="true" />
&lt;/annotationSets>
%>

Note that a service can use the same set for both input and output, and can use the default annotation set (the second example above).

The traditional GATE environment will have a plugin to connect to a GATEService
as to a normal GATE Application, in that case a GATEService should be able to
take as input the content of a document and not only a reference to it in a
DocumentService.  The GaS parameters would translate to runtime parameters on
the GATEServicePR.

Therefore we can distinguish 2 types of Gas:


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%3 GATE mode

In this mode the GaS behaves roughly like a current GATE application, i-e it
takes a document and a set of parameters as input and returns a modified
document. This mode is required in order to incorporate a GaS in a GATE
application, like any other PR.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%3 Remote DataStore

In this mode a GaS does not expect the document as input but only a *task*, i-e
the location of a
document on a remote DocService, taskID, location of an executive service and a
set of parameter values. When
the document is annotated (or processing fails), the GaS communicates directly
to the executive to tell it that the task is complete (or failed). This mode is
required in SAFE.

A new functionality should be created in GATE in order to be able to generate a
simple service deployment (with everything running on a single server) with a
couple of clicks. The result of this operation will be a WAR file, ready to be
unpacked in a web application server.  If you need a more advanced deployment,
e.g. on a cluster, then more administrative intervention will be required.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 DocService

The current storage API is defined in the gate.Datastore interface. It is
implemented by SerialDataStore and DatabaseDataStore. The SerialDataStore uses
the JAVA default object serialization mechanism. The DatabaseDataStore has
currently two implementations for Oracle and Posgresql. The organisation of
the databases is isomorphic with the GATE document architecture. A DataStore
has very limited searching functionalities, a LR can be found by its ID, name
or type. It is not possible for instance to search a LR depending on its
content. The retrieval of information is straightforward, a whole LR can be
obtained using the API (e.g. reference to a corpus, document, ontology) but
not a subpart of it.

In the context of SAFE it would be necessary to access a remote datastore
through Web Services. In order to reduce the amount of information exchanged
on the network, it would be better to retrieve only a part of a LR, e.g. an
AnnotationSet and not a whole document.The idea is to improve the current
storage API by adding a search API (a la ANNIC) and thus have RDBMS-like
functionalities (storing/querying/retrieving). The ANNIC application would
then become a thin application querying and displaying the output of a
searchable datastore.  The indexing and querying of the data would be made on
the remote server. 

A Searchable DataStore will be accessible through a web service. The
underlying implementation will be hidden to the user, it can be a database,
file serialization or memory based system used internally for the storage. The
datastore can run for instance inside a web service container such as Axis on
a remote server. Some Java classes will be developed to implement the service.

From the client perspective, we could have a new type of DataStore in GATE
which would connect to the remote DocService. The behaviour would be exactly
the same as with the other datastores. Not all functionalities of the
Searchable DataStore have to be implemented at once. The main difference
between the old DataStore and the DocService is that in the later only
documents will be stored, and not any type of serializable GATE resource.


*Locking mechanism*

A locking mechanism will be implemented at the AnnotationSet level. A resource
will be locked unless the document is marked as read-only or the content is
obtained in read-only mode (i-e the module requesting knows that it will not
modify a given AnnotationSet). The lock will remain locked until a modified
version is committed, or the lock is explicitly released.

An AnnotationSet could also be obtained as read-only, in which case the module
using it would not be allowed to modify it. The DocService will generate a
taskID and keep internally an information about  whether or not the client is
allowed to modify the resource. In other words, a client using the DocService
will have to ask for the right of modifying a resource by locking it.

The text of a document will not be modifiable. It means that in order to
modify the text of a document, one would have to create a new document and
delete the old one.  *How to retrieve the text of the document?* Is it
automatically returned with the AnnotationSet every time or can it be accessed
via a specific mechanism?


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 Ontology Service

SAFE will use an existing solution for storing ontologies and knowledge bases
such as OWLIM. The definition of the web service will be based on the Semantic
Repository and Query APIs developed by Ontotext.

The Ontology Service will be accessible from the GATE environment, and its
reference will be passed to GATEServices for processing a corpus/document.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 User interfaces

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%3 Language Engineer UI

A Language Engineer builds GATEServices that are used by a SAFE executive.
SAFE being an architecture, it is independent from the tools, however for our
implementation, we will probably use GATE as a Language Engineer UI.

Some modifications will have to be made in GATE: 
- Accessing a remote SearchableDatastore
- Accessing an ontology/kb stored remotely
- Publishing a local GATE application as a GATEService


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%3 Annotator UI

The Annotator UI is used by Human Annotators to connect to an Executive and
get a list of documents to process with regard to a given ontology. The
interface will be used to display documents and annotate them. It will also be
possible to see the content of a given ontology. 

Documents will have different priorities (low/normal/high). Depending on the
priority, a document will have a different colour in the list of documents to
process.

*Idea*: When a new high-priority document is added when none currently exists
an interrupt message will be displayed and the HA will start working on the
new document.

This means that the AnnotatorUI will periodically ask the AnnotatorPool
whether a more important document has to be processed.

From an implementation point of view, the Annotator UI will be implemented as
a Java Web Start application, reusing as much as possible SLUG components. By
using JWS, it will be possible to connect directly to an Executive via Web
Services. 

The Annotator UI will also cater for localisation, with system messages
available in different languages.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%3 Curator UI

An Information Curator is in charge of setting up an Executive module. This
profile being completely new and not covered yet by any existing resource, a
new set of resources will have to be implemented. The Curator UI will have to
communicate with an Executive service. This UI will be a Web Application (JSP
or Servlets). Some of functionalities such as corpora management will be
provided by GATE. The other functionalities are:
- managing the AnnotatorPool (e.g. seeing the current status of job queues in
  the active AnnotatorUIs, etc.)
- creating corpora (with a list of URLs for instance) and inform the executive
  that they have to be processed by passing the references of the corpus in
  the DocService
- configuring the Executive (i-e combining SAFE modules)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%1 Web service APIS

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 DocService API

Here are  the functionalities of a Web Service interface for a DocService.

%[
| *name*	| *description* | *input* | *output* |
----
| listCorpora | list of available corpora	|  none |  list of corpusid |
----
| listDocs | ids of documents stored in a corpus |  corpusid |  list of docid
|
----
| corpusInfo | info about a corpus |  corpusid |  corpusinfo |
----
| newCorpus | creation of a corpus |  corpusinfo |  corpusid |
----
| delCorpus | deletion of a corpus |  corpusid |  none |
----
| newDoc | creation of a document |  corpusid,xmlcontent |  docid |
----
| docInfo | info about a document |  docid |  docinfo |
----
| delDoc | deletion of a document |  docid |  none |
----
| search | ids of documents matching a given query | corpusid, query, start, 
length|list of matches |
----
| getContent | retrieve a specific part of a document (e.g. annotationset - text)|
docid,list of AnnotationSetsID,readOnly | xmlcontent, taskID |
----
| modifyContent | modify a specific part of a document, the lock is
automatically |
removed | docid,xmlcontent, taskID | none |
----
| releaseLock | removes the lock on an AnnotationSet |
docid, taskID | none |
%]

Definitions
- corpusid: string of characters
- corpusinfo: number of documents in the corpus, date of creation and last
  modification
- docid: string of characters
- docinfo: (to be defined) - may contain a list of corpusid, an integer
  representing the length of the document.
- query: covers queries on text and annotations (?)
- match: info about a match for a given search (do be specified). Will
  contain a docid and possibly the offsetstart and offsetend of the hit in the
  document.
- xmlcontent: text or annotations represented as XML
- taskID: String used to identify a task
- AnnotationSetsID: Identificator for an AnnotationSet
- readOnly: boolean indicating whether the resource has to be locked

Ideas / Issues: 
- modify more than one AnnotationSet?
- Have properties for the corpora / documents to allow indexing / querying?

The users should be able to issue JAPE queries over the indexed corpus and
retrieve annotation patterns. Below are some examples of JAPE patterns.
Actual patterns can also be a combination of one or more of the following
pattern clauses:
- String (e.g. "Julien Nioche")
- {AnnotationType} (e.g. {Mention})
- {AnnotationType == String} (e.g. {Person == "Aswani"})
- {AnnotationType.feature == featureValue} (e.g. {Person.gender=="male"})
- {AnnotationType1, AnnotationType2.feature == featureValue} (e.g. {Person,
  Token.orth == "upperInitial"})
- {AnnotationType1.feature == featureValue, AnnotationType2.feature ==
  featureValue} (e.g. {Person.gender=="male", Token.orth=="allCaps"})
- ({pattern})\*n - zero or upto n occurances of the specified pattern (e.g.
  {Title} ({Token.orth=="upperInitial"})\*2)
- ({pattern})+n - one or upto n occurances of the specified pattern (e.g.
  {Title} ({Token.orth=="upperInitial"})+2)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 Ontology / KB Service

Reuse the existing Ontology API in GATE.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 GATEService

A GATEService has the following query operations (returning string arrays): 
- getRequiredParameterNames()
- getOptionalParameterNames()
- getInputAnnotationSetNames()
- getOutputAnnotationSetNames()

The main meat of the service is in the following two operations:

- processDocument (XMLcontent, parameters) %br
  returns: zero or more annotation sets as XML
- processRemoteDocument (execLocation, taskID, dsLocation, docID, parameters,
  asMappings) %br
  returns: none

processDocument provides the "GATE mode" described above:

*XMLcontent*: a GATE document in GATE XML format.  This is expected to contain
at least the annotation sets required as input by the service.

*parameters*: an array of name/value pairs giving String values for the
parameters expected by this GaS.  It is an error if the parameter list does not
specify a value for each required parameter name, though the value specified
may be null.

It returns an array of name/value pairs where the name is an annotation set
name and the value is the XML representation of that annotation set (as per
^DocumentStaxUtils.writeAnnotationSet^), one entry per output annotation set
name (possibly zero if, for example, the service is training a classifier and
doesn't need to return any output).  It is expected that the caller would
replace the content of each annotation set on the original document with the
content returned from the service.

processRemoteDocument provides the "SAFE mode":

*execLocation*: a URL (xsd:anyURI) giving the location of the executive which
should be informed when the process completes (successfully or unsuccessfully)

*taskID *: task identifier that identifies this task to an Executive.

*dsLocation*: a URL giving the location of the document service in which the
document to be processed resides.

*docID*: the ID of the document in the doc service.

*parameters*: as above

*asMappings*: an array of name/value pairs mapping the annotation sets
expected by the GaS to annotation sets on the document in the doc service.  A
mapping is required for each input and output annotation set name the service
uses.  It is permitted for the same doc-service annotation set name to map to
more than one GaS asName, but there is no guarantee as to the order in which
output sets are written back to the doc service, so don't map two output sets
onto the same set in the doc service.  The purpose of this mapping is to allow
the same service to operate over different annotation sets, for example the
results of different human annotators.

processRemoteDocument does not return anything directly - the success or
failure of the operation is communicated out-of-band to the executive.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 AnnotatorPool

The following functionalities will have to be available for AnnotatorGUIs.

- getListOfDocuments (userID) \ returns: list of docInfos
- finishedTask (taskID)

The Executive also needs to assign a task to the Annotator Pool
- setTask(taskID,documentRef,parameters)

*How to set the parameters? XML? the reference to an ontology can be passed as
a parameter, same for the document*

- need to manage the users at this level. This is done by an InfCurator
- addAnnotator(userID,password)
- removeAnnotator(userID,password)

- parameters such as number of HAs required for each document or how to
  combine the ouput of two different users can be passed to the AnnotatorPool
  as parameters.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 Executive

Needs to receive a message about the completion or failure of a task
- finishedTask (taskID)
- taskFailed (taskID)

Has to be configured i-e receive a workflow, which can be represented as an XML
document (to make things simple at the begining). 
- setWorkflow (XML configuration)

It can be queried directly by a client, which sends the content of a document: 
- processDoc (XMLcontent)

which internally: 
o creates a corpus
o creates a document
o put the document in the corpus
o processes the document
o loads the content of the document in memory
o deletes the temporary corpus
o returns the content as XML

Similarly the operation:
- processCorpus (corpusInfo)

will give the reference to a corpus of documents located in a DocService and
inform the Executive that it has to be processed. That operator might return a
taskID, which could be used to display the evolution of the process.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%1 Build

%2 Building SAFE

SAFE has a top-level build file (safe/build.xml) that calls all the subsidiary
build file targets in the right order to build the complete SAFE system.  When
you first check out SAFE from subversion you will need to do a complete ant
build by running ^ant build-all^ in the ^safe^ directory to create all the JAR
files that tie the components together (e.g. the web service client stubs used
to make calls to the doc service, GATE service, etc.).

Libraries used by SAFE components are stored in directories under ^safe/lib^.
Generated JAR files such as ^docservice-client^ are placed in directories under
^safe/lib/exports^ - this directory is (deliberately) not under version
control.

%2 Eclipse settings

To use the SAFE projects in Eclipse you will need to set a _classpath variable_
in Eclipse to enable the project files to find their required libraries.  Open
your Eclipse preferences (Window/Preferences) and go to Java/Build
Path/Classpath Variables.  Create a variable called ^VCS\_TOP^, and point it to
the directory in which you have checked out ^safe^ (and ^gate^, ^gate-extras^
etc.).  The SAFE component project files are set up to find their dependencies
under ^VCS\_TOP/safe/lib^.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 Executive application installation and build

- Create empty schema in your MySQL DB (executive\_db)
- copy build.properties to executive-build.properties
- modify entries in executive-build.properties to match your environment
- execute ant setup-db (that will create tables and data in your DB)
- execute ant deploy
- start tomcat

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 JBPM Graphical Designer Installation

- Download %(http://www.eclipse.org/downloads/download.php?file=/eclipse/downloads/drops/R-3.2-200606291905/eclipse-SDK-3.2-win32.zip, eclipse-SDK-3.2-win32.zip) place downloaded file in 'jbpm-designer' folder
- Go to 'jbpm-designer' folder and execute ant (default target)
- Execute designer.bat in 'jbpm-designer' folder. If Eclipse is started up, everything should be OK
- You can learn how to design WF processes in JPDL by watching nice %(http://docs.jboss.com/jbpm/v3/demos/movies/jbpm-overview.htm, demo) 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 JBPM build and deploy
- edit hibernate.properties in 'jbpm-db/mysql' (4 entries to match your DB settings). By default it is MySQL DB called executive\_db.
- edit 'create.db.hibernate.properties' in jbpm/src/resources (4 entries to match your DB settings). By default it is MySQL DB called executive\_db.
- Open 'hibernate.cfg.xml' from  'jbpm/src/config.files' and edit 4 entries to match your DB settings. By default it is MySQL DB called executive\_db.
- copy build.properties into local.properties and edit ant.home, jbpm.home,  (the folder where this file resides)
- To set a DB run ANT script 'ant -buildfile build.deploy.xml create.db', from 'jbpm' folder. 
- In development run ANT script 'ant -buildfile build.deploy.xml deploy.jbpm', from 'jbpm' folder.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%1 Best practices for SAFE development

- All build files should ^<import file="../lib/lib.xml" />^ (or whatever the
  appropriate relative path is from the build file).
- Construct your classpaths using the patternsets defined in ^lib.xml^.
%<
&lt;path id="classpath">
  &lt;!-- lib.dir is a property defined by lib.xml containing the absolute
       path to safe/lib -->
  &lt;fileset dir="${lib.dir}">
    &lt;patternset refid="pattern.gate" />
    &lt;patternset refid="pattern.docservice-proxy-api" />
  &lt;/fileset>
&lt;/path>
%>

- If your code depends on a library that is exported by another component then
  you should place a _require_ task, e.g. ^<require lib="docservice-proxy-api"
  />^ at the appropriate place (typically just before the relevant ^<javac>^).
  This will stop the build with a useful message if the required library has
  not yet been built.
- If your code uses ^docservice-proxy^, ^executive-proxy^ or ^gas-safe-client^,
  then you should only depend on the relevant ^-api^ lib at compile time.  The
  ^-impl^ JAR should only be included at runtime, or when building a WAR, etc.
- Since the ^<patternset>^s defined in lib.xml are relative to ^${lib.dir}^ you
  will have to copy lib files into a staging directory before building a WAR
  file.  The following will not work:
%<
&lt;war destfile="...">
  &lt;lib dir="${lib.dir}">
    &lt;patternset refid="pattern.gate" />
  &lt;/lib>
&lt;/war>
%>
as it will put the JAR files into ^/WEB-INF/lib/gate-4.0/...^ instead of
directly in ^/WEB-INF/lib^.  Instead you must copy the JARs into a temporary
directory first:
%<
&lt;!-- note the flatten="true" in the following copy task -->
&lt;copy todir="${webinf-lib}" flatten="true">
  &lt;fileset dir="${lib.dir}">
    &lt;patternset refid="pattern.gate" />
  &lt;/fileset>
&lt;/copy>
&lt;war destfile="...">
  &lt;lib dir="${webinf-lib}" />
&lt;/war>
%>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%1 Annex A: workflow for a simple annotation application

We consider here the case of the MOWER application  
(see %(./gleam-app.html)) and present the different interactions between the
modules.

We assume that a remote OntologyService exists already,
containing an ontology of products and more specificaly of digital cameras,
along with a knowledge base of already identified entities (e.g. camera models).

We first describe the case where a GATEService is already available for
annotating the documents with regard to an ontology. In this configuration, a
pool of Human Annotators is available to correct the output of the system. The
GATEService used here has also a module which gives a score to a document,
depending on the number of annotations found in the document in relation to
the size of the document. This information will be used e.g. to determine
whether a document contains too little annotations and thus has to be checked
manually by a HA.

The AnnotatorPool is set up to have only one manual Annotation per document.
The workflow described below can be seen as:

%image(images/executive-scenario1.png)

Here are the different steps for this application: 

- the Information Curator wants to create an initial corpus. There are several
  options: 
  - he sets up a GATEService to crawl the web. This GATEService will populate
    a corpus on a DocService. The reference of the remote corpus is given as a
    parameter
  - the documents are already available localy. The IC can create a corpus on
    a DocService and add the documents via a specific web interface, or GATE,
    provided that there is a docService client implementation for GATE,
    extending the DataStore API.
- as a result the documents are now accessible via the DocService
- the Executive module contacts the GATEService and gives him the parameters
  it requires for each document of the corpus such as its location on a
  DocService and the reference to an OntologyService. Each time the Executive
  calls the GATEService, it also passes an ID which corresponds to a Task
  which is stored in a stack by the Executive.
- A Task is defined by an ID and corresponds roughly to the state of a
  document in the workflow
- The GATEService might internally dispatch the Documents among several
  machines in order to speed up the process. However this is transparent for
  the Executive
- The GATEService loads each document from the DocService and annotates it,
  using information from the OntologyService
- Every time a document has been processed, it is saved in the DocService
- For each document, the GATEService informs the Executive that it has
  completed its task by sending the task ID.
- For each task ID received, the Executive proceeds to the next step in the
  workflow by creating a new Task for the corresponding document
- In this application, the Executive is set up to check the value of a feature
  in the document and send it to the manual annotation if necessary
- In order to check the value of the feature, the Executive needs to connect
  to the DocService and ask it to return the value of the feature for the
  document (or returns the whole document  - the executive will search for it)
- If the value of the features does not require a manual annotation, no
  further task is created for the document, which is stored in the DocService
  and can be used in a end-user application
- If a manual annotation is required, a task is created for the document
- The Executive sends the information about the document and the ontology to
  the AnnotatorPool, along with a task ID.
- The AnnotatorPool keeps an internal stack of tasks for the HAs
- When an AnnotatorGUI connects to the AnnotatorPool and asks for a task, the
  AnnotatorPool gives him a reference to the document in the DocService and
  points to the OntologyService. It also gives a task ID.
- The AnnotatorGUI fetches the information it needs from the DocService, i-e
  the text, plus the AnnotationSet where the ontology entities are stored
  (*how does it know about it? A parameter?*)    
- The AnnotatorUI copies the AnnotationSet into the AnnotationSet of the user
  (* or is it done by the AnnotatorPool? Avoid locking the original AS*)
- the document is manually annotated
- When the manual annotation is finished, the AnnotatorGUI saves the
  AnnotationSet of the user in the DocService and returns the taskID to the
  Executive
- There is only one HA to be used in this application, so there is no need for
  merging the data or making sure that the results are correct
- The AnnotatorPool saves the user AS as the original AS where the entities
  where located, the AnnotatorAS is kept
- The AnnotatorPool returns the taskID to the Executive to inform that the
  task has been finished

This application would be set up with the following XML file: 

%<
&lt;workflow>
&lt;globalParam name\="ontology"
  value\="http://onto.dcs.shef.ac.uk:8080/OntoService?name\=cameras"/>
&lt;service id\="S1"
  url\="http://pebble.dcs.shef.ac.uk:8080/GATEService?name\=preprocess" />
&lt;!-- Connects to an Annotator Pool -->
&lt;service id\="S2"
    url\="http://pebble.dcs.shef.ac.uk:8080/AnnotatorPool?name\=cameras">
  &lt;condition feature\="needsManualAnnotation" value\="true"/>
  &lt;param name\="minimumAnnotors" value\="1"/>
  &lt;param name\="inputAS" value\="automatic"/>
  &lt;param name\="outputAS" value\="manual"/>
&lt;/service>
&lt;/workflow>
%>


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%1 Annex B: workflow for a Machine Learning application

%image(images/executive-scenario2.png)

In the following application, a GATEService is used to pre-annotate a corpus
before passing it to an AnnotatorPool. This preprocessing may for instance
recognize some simple entities using a set of preexisting resources (e.g.
Gazeteers). A ML process is used as a separate GATEService and is used before
the manual annotation in order to produce annotations if a model has been
generated. The manual annotation is provided by several HAs, with an
inter-annotator agreement measure done by the AnnotatorPool in order to have
an idea of the quality of the output. The GATEService containting the Machine
Learning resource takes the output to build a model. 

Note that a ML resource can be combined with other resources inside a
GATEService. However, in the application described here, we need to use the
same resource for classifying the text (before the manual annotation) and
learning (after the manual annotation).

- A Corpus is stored on a DocService
- For each document of the corpus, the Executive sends its location, a
  reference to an ontology, a set of parameters and a taskID to a GATEService
  for the preprocessing
- Every time a document is processed the GATEService informs the Executive
  that the task is completed by returning the taskID
- The Executive creates a new task and sends all the required information to
  the GATEService in charge of the learning
- One of the parameters of the GATEService specifies that the learning PR must
  be used for classifying (and not training)
- The GATEService uses the machine learning. If the system is able to generate
  annotations (the confidence threshold is higher than a parameter specified
  by the application), these are added to the document in the DocService
- The GATEService then returns the taskID to the Executive
- The Executive sends the information about the document and the ontology to
  the AnnotatorPool, along with a task ID.
- The AnnotatorPool keeps an internal stack of tasks for the HAs
- In this application, the InformationCurator specifies that a document has to
  be annotated by two different HAs
- The task about the document to be annotated keeps an information about who
  already worked on a given document, so that a document is not sent twice to
  the same HA
- When an AnnotatorGUI connects to the AnnotatorPool and asks for a task, the
  AnnotatorPool gives him a reference to the document in the DocService and
  points to the OntologyService. It also gives a task ID.
- The AnnotatorGUI fetches the information it needs from the DocService, i-e
  the text, plus the AnnotationSet where the ontology entities are stored
- The AnnotatorUI copies the AnnotationSet into the AnnotationSet of the user
- The document is manually annotated
- When the manual annotation is finished, the AnnotatorGUI saves the
  AnnotationSet of the user in the DocService and returns the taskID to the
  Executive
- The same document is then annotated by a different person, using the same
  procedure
- The document is then available on the DocService with the annotation for
  both human annotators stored in different AnnotationSets
- When the number of annotation required has been reached, the AnnotatorPool
  computes an AnnotatorAgreement measure and determines which annotations are
  to be kept
- Note: The AnnotatorAgreement measure could be achieved by a GATEService and
  not by the AnnotatorPool
- These annotations (found by all annotators) are copied to the target
  AnnotationSet
- The users AnnotationSets are kept
- The AnnotatorPool returns the taskID to the Executive to inform that the
  task has been finished for this document
- The Executive creates a new Task for the document and sends all the
  information required to the GATEService (the one doing the ML). One of the
  parameters of the GATEService specifies that the learning PR must learn from
  the annotationSet
- The GATEService then informs the Executive that it has finished with the
  document by returning the taskID

This would probably be represented by the following XML configuration file: 

%<
&lt;workflow>
&lt;globalParam name\="ontology"
  value\="http://onto.dcs.shef.ac.uk:8080/OntoService?name\=cameras"/>
&lt;service id\="S1"
  url\="http://pebble.dcs.shef.ac.uk:8080/GATEService?name\=preprocess">
&lt;/service>
&lt;service id\="S2" url\="http://ml.dcs.shef.ac.uk:8080/GATEService?name\=ml">
  &lt;param name\="learn" value\="false"/>
   &lt;param name\="confidencethreshold" value\="0.7"/>
   &lt;param name\="outputAS" value\="automatic"/>
&lt;/service>
&lt;!-- Connects to an Annotator Pool -->
&lt;service id\="S3"
  url\="http://pebble.dcs.shef.ac.uk:8080/AnnotatorPool?name\=cameras">
   &lt;param name\="minimumAnnotors" value\="2"/>
   &lt;param name\="fusion" value\="1"/>
   &lt;param name\="inputAS" value\="automatic"/>
   &lt;param name\="outputAS" value\="manual"/>
&lt;/service>
&lt;service id\="S4" overrides\="S2">
   &lt;param name\="learn" value\="true"/>
&lt;/service>
&lt;/workflow>
%>
